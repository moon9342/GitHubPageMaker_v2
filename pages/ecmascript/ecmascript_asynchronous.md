---
title: ECMAScript 6.0 asynchronous
sidebar: ecmascript_sidebar
summary: ""
permalink: ecmascript_asynchronous.html
folder: ecmascript
---

## 동기 처리와 비동기 처리

앞서 closure에서 살펴보았듯 함수를 호출하면 함수 코드가 평가되어 함수 execution context가 생성됩니다. 이때 생성된
함수 execution context는 execution context stack(일명 call stack)에 push되고 함수 코드가 실행됩니다. 
<br><br>

함수 코드의 실행이 종료되면 함수 execution context는 call stack에서 pop되어 제거됩니다.

아래의 코드가 실행되면 그림과 같이 execution context stack이 변하게 됩니다.

~~~javascript

const foo = () => {};
const bar = () => {};

foo();
bar();

~~~

{% include image.html
file='es6-async/es6-async-1.png'
%}

execution context stack에 함수 실행 컨텍스트가 푸시되는 것은 바로 함수 실행의 시작을 의미합니다. 함수가 호출된 
순서대로 순차적으로 실행되는 이유는 함수가 호출된 순서대로 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되기 때문입니다.

이처럼 함수의 실행 순서는 실행 컨텍스트 스택으로 관리됩니다. 

여기서 중요한 점은

자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 가진다는 것입니다. 이는 함수를 실행할 창구가 단 하나이며 2개 이상의
함수를 동시에 실행시킬 수 없다는 것을 의미합니다. 

즉, 실행 컨텍스트 스택의 최상위 요소인 실행 중인 실행 컨텍스트를 제외한 모든 실행 컨텍스는 모두 실행 대기 중인 `task`들 입니다.

대기 중인 task들은 현재 실행 중인 실행 컨텍스트가 팝되어 실행 컨텍스트 스택에서 제거되면 즉, 함수가 종료되면 비로소 실행될 수 있습니다. 

이처럼 자바스크립트 엔진은 한번에 하나의 task만을 실행 시킬 수 있는 single thread 방식으로 동작합니다. 

당연한 말이지만 싱글 스레드 방식으로 동작하기 때문에 처리에 오랜 시간이 걸리는 task를 실행할 경우 당연히 `blocking`(작업중단)이
발생할 수 있습니다. 

다음의 예를 보죠.

~~~javascript

function sleep(func, delay) {


    // Date.now()는 현재 시간을 ms 단위의 숫자로 변환합니다. 
    // 1970년 1월 1일 0시 0분 0초부터 현재까지 경과된 밀리 초를 반환
    const delayTime = Date.now() + delay
    console.log(delayTime);

    while( Date.now() < delayTime);

    func();
}

function foo() {
    console.log('foo');
}

function bar() {
    console.log('bar');
}

sleep(foo, 3*1000);

bar();

~~~

코드를 실행하면 알겠지만 sleep 함수는 3초뒤에 foo 함수를 호출합니다. bar 함수는 foo 함수 이후에 실행되므로 foo의
실행이 종료될 때 까지 호출되지 못하고 `blocking`됩니다. 

이처럼 현재 실행 중인 task가 종료될 때 까지 다음에 실행될 태스크가 대기하는 방식을 동기(synchronous) 처리라고 합니다.

동기처리방식은 태스크를 순서대로 하나씩 처리하므로 실행 순서가 보장된다는 장점이 있지만 앞선 태스크가 종료될 때까지 이후
태스크들이 모두 blocking된다는 단점이 있습니다. 

그림으로 보면 다음과 같습니다. 

{% include image.html
file='es6-async/es6-async-2.png'
%}

자 이번에는 자바스크립트가 제공하는 타이머 함수를 사용해보죠.

~~~javascript


function foo() {
    console.log('foo');
}

function bar() {
    console.log('bar');
}

// setTimeout 함수는 일정 시간이 경과한 이후에 콜백함수 foo를 호출합니다.
// setTimeout 함수는 bar 함수를 blocking시키지 않습니다. (non-blocking 함수)

var result = setTimeout(foo, 3*1000);

console.log(result);

bar();

~~~

위의 예제에서 setTimeout 함수는 이후의 task를 blocking하지 않습니다. 이처럼 현재 실행 중인 태스크가 
종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 비동기(asynchronous) 처리라고 합니다. 

이와 같은 비동기 처리 방식은 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하므로 
블로킹이 발생하지 않는 장점이 있지만 태스크의 실행 순서가 보장되지 않는다는 단점이 있습니다. 

비동기 처리를 수행하는 비동기 함수는 전통적으로 callback 패턴을 사용합니다. 하지만 이런 비동기 처리를 위한 콜백 패턴은
콜백 헬을 발생시켜 가독성을 나쁘게 만들고 비동기 처리 중 발생한 에러에 대한 예외 처리가 힘듭니다. 또한 여러개의 비동기
처리를 한번에 처리하는 것도 프로그램을 아주 어렵게 만드는 요인이 됩니다. 

---

## 이벤트 루프와 태스크 큐

그런데 무언가 이상하지 않나요??

자바스크립트의 특징 중 하나는 싱글 스레드로 동작한다는 것입니다. 싱글 스레드 방식은 한번에 하나의 태스크만 처리할 수 있다는
것을 의미합니다. 하지만 브라우져가 동작하는 것을 보면 많은 태스크가 동시에 처리되는 것처럼 보입니다. 

예를 들면, HTML 요소가 애니메이션 효과를 내며 움직이면서 이벤트 처리가 가능하고 서버와의 데이터 통신을 하면서 데이터를 가지고
오면서 동시에 랜더링이 진행됩니다. 

어떻게 이러한 현상이 발생할 수 있을까요?

이처럼 자바스크립트의 동시성을 지원하는 것이 바로 `event loop`입니다. 

이 이벤트 루프는 브라우저에 내장되어 있는 기능입니다. 자바스크립트 엔진의 기능이 아니라는 거죠.

{% include image.html
file='es6-async/es6-async-3.png'
%}

천천히 한번 살펴보겠습니다. 

우리가 사용하고 있는 V8엔진과 더불어 거의 대부분의 자바스크립트 엔진은 크게 2개의 영역으로 구분할 수 있습니다. 

### call stack

소스코드 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택이 바로 콜 스택입니다. 
함수를 호출하면 함수 실행 컨텍스트가 순차적으로 콜 스택에 푸쉬되어 순차적으로 실행됩니다. 자바스크립트 엔진은 단 1개의 콜 스택을
사용하기 때문에 최상위 실행 컨텍스트가 콜 스택에서 제거되기 전까지는 다른 어떤 태스크도 실행 될 수 없습니다. 

### heap

힙은 당연히 객체가 저장되는 영역입니다. 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조하면서 동작합니다. 

여기서 주의해야 할 점은 비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 브라우져에서
담당한다는 것입니다. 

조금 풀어서 설명하면 비동기 방식으로 동작하는 setTimeout의 콜백 함수의 평가와 실행은 당연히 자바스크립트 엔진이 담당하지만 호출
스케쥴링을 위한 타이머 설정과 콜백 함수의 등록은 브라우져가 담당한다는 의미입니다. 

브라우져는 이 작업을 하기 위해 태스크 큐와 이벤트 루프를 제공합니다. 

### 태스크 큐

setTimeout과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역입니다.

### 이벤트 루프

이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지 그리고 태스크 큐에 대기중인 함수(콜백함수)가 있는지를 반복해서 확인합니다.
만약 콜 스택이 비어있고 태스크 큐에 대기중이 함수가 있다면 이벤트 루프는 FIFO방식으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킵니다.
당연히 콜 스택으로 이동한 태스크는 실행되게 됩니다. 즉, 태스크 큐에 일시 보관된 함수들은 비동기 처리 방식으로 동작합니다. 

다음의 예를 보죠.

~~~javascript


function foo() {
    console.log('foo');
}

function bar() {

    // 나중에 이 주석을 지우고 실행해보자.
    // 이 경우 foo 함수는 당연히 콜 스택이 비어 있지 않기 때문에 실행되지 못한다.
    // const delayTime = Date.now() + 1000*5
    // while( Date.now() < delayTime);

    console.log('bar');
    
}

setTimeout(foo, 0);  // 0초를 명시했지만 지연시간이 4ms 이하이면 최소지연시간인 4ms로 설정합니다.

bar();

~~~

실행 순서를 한번 살펴보도록 하겠습니다. 

1. 전역 코드가 평가되어 전역 실행 컨텍스트가 생성되고 콜 스택에 푸쉬됩니다. 

2. 전역 코드가 실행되기 시작하여 setTimeout 함수가 호출됩니다. setTimeout 함수의 함수 실행 컨텍스트가 생성되고
콜 스택에 푸쉬되어 현재 싱행 중인 실행 컨텍스트가 됩니다. 브라우져의 Web API인 타이머 함수도 함수이기 때문에 당연히
함수 실행 컨텍스트를 생성합니다. 

3. setTimeout 함수가 실행되면 콜백 함수를 호출 스케쥴링하고 바로 종료되어 콜 스택에서 제거됩니다. 이때 타이머 설정과
타이머가 만료되면 콜백 함수를 태스크 큐에 푸쉬하는 것은 브라우져의 역할입니다. 

4. 이제 다음의 두가지 일이 병행됩니다. 첫번째는 브라우져는 타이머를 설정하고 만료를 기다립니다. 만약 타이머가 만료되면 콜백
함수 foo가 태스크 큐에 푸쉬됩니다. 위의 예제 같은 경우 지연시간이 4ms이기 때문에 4ms 후에 콜백 함수 foo가 태스크 큐에 푸쉬되어
대기 하게 됩니다. 당연히 이 작업은 브라우져가 하게 됩니다. 그리고 지연 시간 이후에 태크스 큐에 푸쉬된 콜백함수는 콜 스택이
비어야 호출되므로 시간차가 발생할 수 있습니다. 두번째는 bar 함수가 호출되어 bar 함수의 함수 실행 컨텍스트가 생성되고 콜 스택에
푸쉬되어 현재 실행 중인 실행 컨텍스트가 됩니다. 이후 bar함수가 종료되어 콜 스택에서 팝 되고 이때 4ms가 경과했다면 foo함수는
아직도 태스크 큐에 대기중일 것입니다. 

5. 전역 코드 실행이 종료되고 전역 실행 컨텍스트가 콜 스택에서 팝 됩니다. 이제 콜 스택에는 아무런 실행 컨텍스트도 존재하지 않게됩니다.

6. 이벤트 루프에 의해 콜 스택이 비어 있음이 감지되고 태스크 큐에서 대기 중인 콜백 함수 foo가 이벤트 루프에 의해 콜 스택에 푸쉬됩니다.


이처럼 비동기 함수인 setTimeout의 콜백함수는 태스크 큐에 푸쉬되어 대기하다가 콜 스택이 비게되면 다시 말해 전역 코드 및 명시적인
함수 호출이 모두 종료되면 비로소 콜 스택에 푸쉬되어 실행되게 됩니다. 

다시 언급하지만 자바스크립트는 싱글 스레드로 동작합니다. 이때 싱글 스레드로 동작하는 것은 자바스크립트 엔진이라는 것이지 브라우저 역시
싱글 스레드로 동작하는 것은 아닙니다. 브라우져는 멀티 스레드로 동작합니다. 



End.

{% include links.html %}
