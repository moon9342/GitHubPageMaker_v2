---
title: MySQL Database Modeling(특강)
sidebar: mysql_sidebar
summary: "이번 시간에는 Modeling이라는 용어와 설계라는 용어에서 오는 모호함에 대해서 알아볼 것입니다. 
이 용어들에 대한 설명과 데이터베이스를 설계라는 작업이 어떠한 절차를 거쳐 진행 되는지를 알아보도록 하겠습니다."
permalink: mysql_database-modeling.html
folder: mysql
---

## Introduction

왜 우리가 `Database Modeling` 혹은 Database 설계를 궁금해 하고 어려워할까요?
한마디로 말하면 배우지 않아서 일 겁니다. 우리는 JDBC와 같은 프로그램을 할 때
Table을 실제로 만들어서 Java 프로그램등과 연동하게 되는데 이 Table을 생성하는
과정은 넓은 범위의 Database 설계단계 중 Database 구축단계입니다.
<br><br>

일반적으로 프로그래밍 교육과정에서는 프로그램과 Database를 연동하는데 초점을 더
맞추고 있기 때문에 아마 이 Database Modeling과 전체적인 설계부분은 조금 등한시 하지
않나 생각됩니다.
<br><br>

이번 시간에는 `Modeling`이라는 용어와 설계라는 용어에서 오는 모호함에 대해서
알아볼 것입니다. 이 용어들에 대한 설명과 데이터베이스를 설계라는 작업이
어떠한 절차를 거쳐 진행 되는지를 알아보도록 하겠습니다.
<br><br>

`Database Modeling` 이라고 불리는 분야는 상당히 이론적으로 알아야 할 용어 및
내용도 상당합니다. `Modeling`에 대해 알아보기 전에 `Database`에 관한
기본적인 용어부터 알아봐야 할 듯 합니다.
<br><br>

간단하게 Database의 역사와 관련된 용어부터 알아보도록 하죠.

---

## File System

초창기 컴퓨터 시스템들은 데이터를 저장하기 위한 기본 방법으로 `File System`을
사용했었습니다. 이름 그대로 `File`에 기초하여 자료나 정보를 처리하는 시스템을 의미합니다.
<br><br>

개별 응용프로그램들이 직접 파일에 접근해 기록, 갱신, 삭제, 조회를 하고 파일에 있는
데이터의 올바른 관리는 전적으로 응용프로그램이 담당하는 구조입니다.
<br><br>

이런 `File System`은 몇가지 치명적인 단점을 가지고 있는데 다음과 같습니다.

* 데이터 종속성(Data Dependency)
<br>
데이터 종속성이란 데이터를 사용하는 프로그램의 구조가 데이터 구조의 영향을 받는
다는 의미입니다. 사용하는 데이터의 저장 형태(파일의 저장 형태)가 변하면 그를
사용하는 프로그램을 수정해야 하는데 이런 경우 프로그램의 개발과 유지보수를 상당히
어렵게 하는 요인이 됩니다.
<br><br>

* 데이터 무결성(Data Integrity)
<br>
데이터 무결성이란 저장된 데이터의 내용이 본래 의도했던 데이터의 형식, 범위를
준수해야 한다는 성질입니다. 예를 들어, 사람 나이는 숫자여야 하고 음수가 아닌
양수여야 하며 그 범위 역시 한정적입니다.
<br><br>
이러한 조건을 위배하는 데이터가 저장될 때 데이터의 무결성이 침해되었다고 말합니다.
`File System`을 사용할 경우 이런 무결성에 대한 책임이 바로 응용 프로그램을 작성하는
프로그래머에게 있고 이는 잘못된 오류를 발생할 여지를 둘 수 있습니다.
<br><br>

* 데이터 중복성(Data Redundancy)
<br>
데이터 중복성이란 같은 내용의 데이터가 여러 곳에 중복되어 저장되는 것을 의미합니다.
이런 경우 동일 데이터가 여러 파일에 중복 저장되는 일이 발생하고 이는 저장 공간의
낭비 뿐 아니라 데이터의 불일치, 보안쪽에서 문제가 발생할 여지가 있습니다.
<br><br>

* 데이터 불일치(Data inconsistency)
<br>
데이터 불일치란 중복 저장된 데이터들이 서로 일치하지 않는 것을 의미합니다. 우리가
웹 사이트에 회원정보를 저장하고 이사를 간 후 그 정보를 수정하지 않는 경우와 비슷하다고
볼 수 있습니다. 이런 경우 이전의 주소로 무언가 날라갈지도 모르죠.
<br><br>

* 데이터 보안(Data Security)
<br>
`File System`은 그 특성상 저장되어 있는 파일 형식이 Text형식으로 되어 있기 때문에
응용 프로그램 없이도 쉽게 내용을 열어 볼 수 가 있고 파일 자체가 유실되거나 의도치
않게 쉽게 공유될 여지가 있습니다. 즉, 보안성이 결여되어 있다고 볼 수 있는거죠.
<br>
이러한 여러가지 문제들이 결국은 더 이상 `File System`을 사용하지 않고
`Database System`으로 넘어오게 되는 계기가 되었습니다.

---

## Database System

초창기에는 `Hierarchical`(계층형) Database와 `Network` Database를 사용하였지만
여러 이유로 결국 현재 우리가 주로 사용하는 `Relational` Database를 이용하게
되었습니다.
<br><br>

관계형 데이터베이스는 1970년대에 `E.F.Codd` 박사에 의해서 발표된
"A Relational Model of Data for Large Shared Data Banks"라는 논문을 기초로해서
만들어진 데이터베이스입니다.
<br><br>

앞으로 우리가 다루는 Database는 이 `Relational` Database를 기본으로 합니다.
물론 현재는 객체-관계형 데이터베이스가 사용되고 있지만 그 원형이 관계형 데이터베이스
이기 때문에 큰 차이는 없습니다.
<br><br>

당연히 이 `Database System`은 `File System`이 가지는 단점을 극복했습니다.
주요한 것들만 살펴보면,
<br><br>

* 데이터의 독립성(Independency) 지원
* 데이터 무결성 유지
* 데이터 중복성 및 불일치 최소화
* 높은 보안성
* 데이터 공유의 용이성
<br><br>

이 정도로 볼 수 있겠네요.
<br><br>

이제 몇몇개의 용어부터 알아보고 넘어가죠.
<br><br>

`Database`라는 용어는 비단 IT분야뿐만 아니라 일반 분야에서도 널리 사용되는 용어입니다.
하지만 정작 `Database`를 정의해보라고 하면 정확하게 말하지 못하는 경우가 많습니다.

{% include callout.html
type="danger"
content="`Database`는 **데이터의 집합**, 조금 더 정확히는 **대용량의 데이터 집합을 체계적으로
구성해 놓은 것** 이라고 정의할 수 있습니다."
%}

또한 이러한 Database는 오직 하나가 아니라 용도에 따라 여러 Database가 존재할 수 있으며
각 Database는 혼자서 사용하는 것이 아닌 여러명의 사용자나 시스템이 서로 공유하면서
사용됩니다. 그렇기 때문에 이런 Database를 관리해주는 시스템 혹은 소프트웨어가 필요하게 됩니다.

{% include callout.html
type="danger"
content="`DBMS`(Database Management System)는 데이터베이스를 관리해 주는 시스템 혹은
소프트웨어를 일컫는 말입니다."
%}

정리를 해보면 `Database`는 데이터의 집합이라고 정의할 수 있고 `DBMS`는 이 `Database`를
관리,운영하는 역할을 수행합니다. 또한 `Database`는 여러 명의 사용자나 프로그램이 공유하고
동시에 접근이 가능해야 합니다.
<br><br>

추가적으로 `Database`는 **데이터의 저장공간 자체**를 의미하기도 합니다. 즉, 파일로 구성되는
디스크 공간을 Database로 취급하기도 합니다.
<br><br>

일반적으로 많이 사용되는 DBMS는 다음 그림과 같습니다.

{% include image.html
file='relational-database-popular-dbms.png'
%}

아시다시피 관계형 데이터베이스에서는 데이터가 `Table` 형태로 표현됩니다.
아래의 그림은 관계형 모델의 관점에서 우리가 사용하는 Table과 관련된 용어들에
대한 설명입니다. 이 용어들은 사실 `E.F.Codd`가 정의한 것으로 오늘날 일반적으로
사용하는 용어와는 차이가 있습니다.

{% include image.html
file='database-mysql-relation-terminology.png'
%}

* relation
<br>
`relation`은 우리가 일반적으로 `table`이라고 지칭했던 것을 의미합니다.
관계형 데이터베이스에서 정보를 구분하여 저장하는 기본단위가 됩니다.
<br><br>

* attribute
<br>
하나의 `relation`은 현실세계의 어떤 `Entity`(개체)를 표현하고 저장하는 데 사용되는데
표현할 `Entity`의 구체적인 정보 항목에 해당하는 것이 `attribute`(속성)입니다.
<br><br>

* tuple
<br>
`relation`이 현실세계의 어떤 개체를 표현한다면 `tuple`은 그 개체에 속한 구성원들
개개의 정보를 표현한다고 할 수 있습니다. 그림에서 처럼 학생은 `relation`이고 김철수,
박선하, 안미희와 같은 이름은 학생 개체의 구성원이라고 할 수 있습니다.
<br><br>

* domain
<br>
`domain`이란 relation에 포함된 각각의 속성들이 가질 수 있는 값들의 집합이라고
할 수 있습니다. 이런 `domain`이라는 개념이 필요한 이유는 relation에 저장되는
데이터 값들이 본래 의도했던 값들만 저장되고 관리되도록 하는데 있습니다. 예를 들면,
성별이라는 속성이 있다면 이 속성이 가질 수 있는 값은 `[남, 여]`로 지정할 수 있고
이를 통해 사용자들이 실수로 다른 값을 입력하는 것을 `DBMS`가 막을 수 있습니다.
<br>
우리는 이 domain을 위해 `data type`과 길이 지정 및 값의 범위 지정같은 것들을
이용합니다.
<br><br>
여러가지 용어가 나왔는데 비슷한 용어들을 알기 쉽게 표로 살펴보면 다음과 같습니다.
{% include image.html
file='database-mysql-terminology-compare.png'
%}
<br><br>

* 기본키와 외래키
<br>
관계형 Database에서는 데이터의 중복을 최소화 하려고 노력합니다. 데이터가
중복되어 있다면 데이터의 불일치와 같은 문제가 발생할 여지가 있고 이 문제를
해결하기 위해 DBMS가 추가적으로 많은 일을 해야 하기 때문입니다.
<br>
하지만 DBMS입장에서는 중복된 row가 table에 삽입되는지를 확인하는 것은 사실
쉬운 작업이 아닙니다. 모든 row에 대해 모든 column이 같은지를 일일이 검사해서
중복 여부를 검사할 수 있지만 시간이 너무 오래 걸리게 되죠.
<br>
그렇다면 어떻게 중복 여부를 효과적으로 확인할 수 있을까요? 이에 대한 대답이
바로 `key`입니다. 정확히는 `candidate key`(후보키)입니다.
<br><br>
`candidate key`(후보키)란 테이블에서 각 tuple을 구별하는 데 기준이 
되는 하나 혹은 그 이상의 attribute(column)들의 집합을 의미합니다.
<br><br>
이런 후보키 중에 하나를 선택해 tuple을 구분하는 용도로 사용하게 되는데
이를 `primary key`(기본키)라고 하며 선택되지 않은 후보키를 `alternate key`
(대체키)라고 합니다.
<br>
이런 후보키와는 달리 table 간의 연결고리 역할을 수행하면서 테이블간의
데이터의 일치와 무결성을 보증해주는 수단이 바로 `foreign Key`(외래키)입니다.
<br>
사실 지금까지 설명한 용어는 기본적인 데이터베이스를 배운사람은 대부분 이해하고
있는 용어일 것입니다. 그러면 이제 조금 다른 얘기를 해보죠.
<br><br>

---

## 데이터베이스 설계란 무엇인가?

데이터베이스 설계에 대한 얘기를 하기 전에 일단 먼저 `abstraction`(추상화)과
`modeling`(모델링) 이라는 용어에 대해서 알아보죠.
<br><br>

사실 이 개념은 우리가 Java와 같은 언어를 배울 때 객체지향 개념을 공부하게 되는데
이때 이미 나온 개념입니다.
<br><br>

데이터베이스 설계 과정은 당연히 소프트웨어 개발 과정의 일부이고 소프트웨어 개발과정은
곧 현실세계에 대한 추상화 과정으로 설명될 수 있습니다.
<br><br>

추상화는 `model`이라는 수단을 통해 이루어지기 때문에 이 추상화를 모델링이라고 하기도 합니다.
무슨말인지 감도 안오죠?
<br><br>

사실 우리는 모델이라고 지칭하지는 않지만 생활 속에서 이 모델을 많이 이용하고 있습니다.
<br><br>

가장 대표적인 예가 바로 지도입니다. 아래의 그림을 보시죠.

{% include image.html
file='database-mysql-seoul-satellite.png'
%}

이 그림은 서울 시가지의 위성지도입니다. 서울의 중심을 지나는 한강을 볼 수 있네요. 하지만 이런
위성사진은 실제 우리 실생활에 도움이 되지 않습니다. 앞의 위성사진은 현실세계를 정확히 반영하고
있지만 이 사진을 보고 내가 원하는 곳을 찾아가는 것은 상당히 힘든 일이 될 것입니다.
<br><br>

이번에는 아래의 사진을 보시죠.

{% include image.html
file='database-mysql-seoul-modeling.png'
%}

위의 지도가 실제로 더 유용하게 사용될 수 있을겁니다. 이와 같이 위성지도가 아닌
일반 지도(약도)에서는 현실세계가 간단한 도형, 색, 색깔로 표현되며 현실세계와 정확히
일치하지는 않지만 현실세계에 대한 `model`의 역할을 충분히 하고 있습니다.
<br><br>

이번에는 또 다른 형태의 지도를 볼까요?

{% include image.html
file='database-mysql-seoul-subway-2.png'
%}

위의 지하철 2호선 노선도는 현실세계를 더욱 개념화 하고 단순화 해서 표현하고 있습니다.
아주 제한적인 정보를 제공하지만 우리는 이 노선도를 보고 대강의 서울 지역을 떠올릴 수 있고
매우 유용하게 사용할 수 있습니다.
<br><br>

자 그럼 정리를 해 보죠.

---

## Model

`model`이란 사람들이 복잡한 현실세계를 쉽게 이해하기 위해 현실세계를 개념화하고 단순화 시켜
표현한 것을 말합니다. 이런 `model`을 만드는 과정을 `modeling`이라 하며, 이러한 과정을
다른 말로 현실세계의 대한 `abstraction`(추상화)라고 합니다.
<br><br>

객체지향 역시 같은 개념을 사용합니다. 우리가 배운 객체지향 프로그래밍은 현실세계를 그대로
프로그램으로 모델링하는데 그 목적이 있습니다. 왜 그렇게 프로그래밍을 하려 하는 걸까요?
객체지향적으로 프로그래밍을 하게 되면 프로그램의 유지보수성을 대폭 높일 수 있기 때문입니다.
<br><br>

그래서 현실세계의 개체들을 프로그램적으로 표현하기 위해 우리가 사용하는 수단이 바로
`class`이고 정보는 `field`로 행위는 `method`로 표현(modeling)하는 것이죠.
<br><br>

그래서 `class`를 **객체 모델링의 수단**이라고 하는 것입니다.
<br><br>

아래의 그림처럼 지도나 약도, 도로 표지판, 악보 등은 현실세계의 어떤 부분을 표현하는
`model`(모델)입니다.
<br><br>

그리고 각 model은 model을 구성하는 요소들(기호, 선, 도형등)을 가지고 있습니다.
이러한 구성요소는 사람들이 직관적으로 알 수 있거나 관습이나 약속에 의해 그 의미가 정해져
있습니다. 지도에서 병원은 십자가, 교회는 집위에 십자가로 표현하자나요. 따라서
우리가 model의 구성요소들의 의미를 이해한다면 그 model을 통해 현실세계를 이해할 수 있게 되는
것이죠.

{% include image.html
file='database-mysql-modeling-concept.png'
%}

이러한 추상화 과정은 소프트웨어 개발(프로그램 개발)과 밀접한 관련이 있습니다. 프로그램이란
현실세계에서 수행되는 작업이나 행위가 컴퓨터세계에서 수행될 수 있도록 해 주는 수단이며 결국
소프트웨어(프로그램)는 현실세계를 모델링한 결과라고 할 수 있습니다.
<br><br>

간단한 예로, 1부터 1000까지 합을 구하는 문제를 생각해보죠. 종이와 연필을 가지고 사람이
이 문제를 푼다면 1+2+3+4+5+.. 와 같이 순차적으로 숫자를 더해 나가는 방법을 사용하겠죠?
<br><br>

컴퓨터로 하여금 이 문제를 해결하도록 하려면 어떻게 해야 할까요?
<br><br>

컴퓨터도 사람이 문제를 푸는 것과 동일한 절차를 거쳐서 풀어야 합니다.
그러기 위해서 컴퓨터에게 문제를 해결하는 절차를 알려줘야 하는데 이게
우리가 말하는 `Algorithm`(알고리즘)입니다. 그리고 그 알고리즘을 프로그래밍 언어로
해결하는 방법을 알려주는 수단이 바로 프로그램입니다.
<br><br>

그림으로 보면 다음과 같습니다.

{% include image.html
file='database-mysql-modeling-code.png'
%}

---

## 데이터베이스 설계의 개념

우리가 웹사이트와 같은 것을 개발할 때 데이터베이스를 제외하고는 생각하기 어렵습니다.
따라서 데이터베이스 연동 프로그래밍이 기본적인 지식으로 여겨지고 있죠.
<br><br>

데이터베이스를 기반으로 시스템을 개발하기 위해서는 당연히 먼저 데이터베이스가
구축되어야 합니다.
<br><br>

데이터베이스 설계를 아주 쉽게 설명하면 데이터베이스안에 어떤 `table`들이 있어야 하고
각 `table`들은 어떤 `column`을 가져야 하는지, 그리고 `primary key`와
`foreign key`는 어떤 것들인지를 정하고 `View`와 `Index`를 생성하는 일련의
과정을 얘기합니다.
<br><br>

그렇기에 데이터베이스를 설계하기 위해서는 우리 객체지향 프로그래밍과 마찬가지로
현실세계에 대한 분석이 있어야 합니다.

{% include callout.html
type="danger"
content="결국 데이터베이스 설계는 단순히 데이터베이스 안에 테이블을 생성하는 과정뿐 아니라
현실세계에 대한 분석, 데이터 모델링이라고 불리는 논리적 설계, 물리적 설계, 데이터베이스
구축에 대한 전 과정을 포함하게 됩니다."
%}

앞서 말했듯이 데이터베이스의 설계는 현실세계에 대한 모델링 과정을 포함합니다.
<br><br>

학생이 수강신청을 하는 상황을 한번 가정해보죠. 아래그림처럼 왼쪽에 있는 학생과
학생의 수강신청 정보는 그림 오른쪽에 데이터베이스 안에서 테이블로, 개별 학생 및
개별 학생의 수강신청 정보는 테이블안의 `tuple`로 표현된 것을 볼 수 있습니다.

{% include image.html
file='database-mysql-database-design-input-output.png'
%}

그림 오른쪽과 같이 데이터베이스가 구축되기 위해서는 그림의 중간에 있는 것과 같이
현실세계를 개념적 모델로 표현하는 단계를 거치게 됩니다. 이 개념적 모델을 우리는
통상 `ERD`(entity-relationship diagram)를 이용해서 표현합니다.
<br><br>

이렇게 현실세계를 분석하여 이를 개념적 모델로 표현하고 이를 바탕으로 데이터베이스를
구축하는 과정을 데이터베이스 설계라고 합니다.
<br><br>

조금만 더 얘기해 보기로 하죠.
<br><br>

위의 그림에서 구현된 데이터베이스를 잘 관찰해보면 현실세계의 어떤 부분은 반영되어
있지만 어떤 부분은 생략된 것을 알 수 있습니다. 즉, 현실세계의 개체와 관련된 정보나
데이터는 나타나 있지만 그러한 개체들의 행위는 나타나 있지 않습니다. 그 이유는
데이터베이스가 현실세계를 컴퓨터세계로 추상화 할때 정보나 데이터 부분을 표현하는데
그 목적이 있기 때문입니다.
<br><br>

그럼 현실세계에 발생하는 행위는 무엇으로 표현될까요? 당연히 프로그램으로 표현됩니다.
<br><br>

데이터베이스 설계는 크게 논리적 데이터베이스 설계와 물리적 데이터베이스 설계로 구분하는데
논리적 데이터베이스 설계는 현실세계를 관찰,분석하고 `ERD`로 불리는 개념적 모델을 만드는
과정을 말합니다. 그래서 논리적 데이터베이스 설계 과정을 `data modeling`이라고
부르기도 합니다. 이런 논리적 데이터베이스 설계를 바탕으로 실제 데이터베이스를 구축하기
위해 `Table`, `View`, `Index`등에 대한 명세를 생성하는 과정을 우리는 물리적
데이터베이스 설계라고 합니다.
<br><br>

당연히 논리적 데이터베이스 설계는 DBMS 제품에 상관없이 이루어지는 것이고 물리적
데이터베이스 설계는 사용하는 DBMS에 종속적이 될 수 밖에 없겠죠?

---

## 데이터베이스 설계 단계

아래의 그림은 소프트웨어 개발 절차인 `waterfall` 모델 입니다. 데이터베이스 설계도
시스템 구축의 일부분이기 때문에 이 모델안에서 어떠한 일을 하는지를 살펴보면 좋을거
같습니다.

{% include image.html
file='database-mysql-waterfall-model.png'
%}

아래의 그림은 시스템 구축 절차를 조금 세분화 시켜놓은 것입니다. 각 단계를 간단하게
알아보도록 하죠.

{% include image.html
file='database-mysql-system-build-step.png'
%}

* Information Strategic Planning(정보전략 계획수립)
<br>
시스템 구축의 선행 단계로 기업의 경영전략 및 장단점 분석, 현행 업무 절차를 평가하여 개선사항등을
도출하여 새로운 전략 및 업무 절차에 기초하여 시스템 구축 계획을 수립하는 단계입니다.
<br><br>
이 단계의 산출물에 대해 간단한 예를 들면 다음 그림과 같습니다.
{% include image.html
file='database-mysql-isp.png'
%}
<br>

* 업무 분석
<br>
ISP 과정을 거치면 업무 분석과 모델링 단계를 거치게 됩니다.
업무 분석은 말 그대로 업무가 어떻게 이루어지는지를 파악하는 것으로 누가 어떤 행위를
하는지, 업무 과정에서 어떤 정보가 발생하거나 오고가는지, 어떤 절차를 거쳐서
업무가 진행되는지를 파악해 문서화 시키는 단계입니다.
<br><br>
이 단계의 산출물(업무흐름도)에 대해 간단한 예를 들면 다음 그림과 같습니다.
{% include image.html
file='database-mysql-task-process.png'
%}
업무분석 이후 단계는 크게 두 가지 흐름으로 진행됩니다. 하나는 데이터 관점에서의
개발과정이고 다른 하나는 `process`(프로세스) 관점에서의 개발 과정입니다.
<br><br>

* 데이터 모델링
<br>
데이터 모델링은 현실 세계를 데이터의 관점에서 파악하여 개념적인 모델로 표현하는
단계이며 논리적 데이터베이스 설계에 해당합니다. 일반적으로 `ERD`가 많이 이용됩니다.
<br><br>
이 단계의 산출물(ERD)에 대해 간단한 예를 들면 다음 그림과 같습니다.
{% include image.html
file='database-mysql-erd-sample.png'
%}
<br><br>

* 프로세스 모델링
<br>
업무가 어떻게 구성되어 있는지, 업무의 처리 절차와 방법이 어떻게 되는지를
파악하는 단계입니다. 프로세스 흐름도 같은 것이 결과로 도출될 수 있습니다.
<br><br>
이 단계의 산출물(프로세스 흐름도)에 대해 간단한 예를 들면 다음 그림과 같습니다.
{% include image.html
file='database-mysql-process-flow.png'
%}
<br><br>

* 상관 모델링
<br>
데이터 모델과 프로세스 모델을 비교 검토하여 서로 간에 잘 맞는지를 평가하는 단계로
이를 상관 모델링 이라고 합니다. 업무의 과정이 명확히 파악되었는지 그리고 업무
과정과 관련된 데이터나 정보가 올바로 파악되었는지를 평가하며 일반적으로
`CRUD` 매트릭스 같은 것들이 사용됩니다.
<br><br>
이 단계의 산출물(CRUD 매트릭스)에 대해 간단한 예를 들면 다음 그림과 같습니다.
{% include image.html
file='database-mysql-crud-matrix.png'
%}
<br><br>

* 물리적 Database 설계
<br>
물리적 데이터베이스 설계는 실제 데이터베이스 구축을 위한 테이블, 뷰, 인덱스
등을 설계합니다. 논리적 설계와는 다르게 데이터베이스의 용량, 성능, 보안요소등도
같이 고려해야 합니다.
<br><br>
이 단계의 산출물(테이블 기술서)에 대해 간단한 예를 들면 다음 그림과 같습니다.
{% include image.html
file='database-mysql-table-description.png'
%}
<br><br>

* 데이터베이스 구축
<br>
이 단계는 우리가 알고 있는 단계입니다. SQL을 이용해서 Table, View, Index등을
생성하는 단계입니다.
<br><br>

* 데이터베이스 튜닝
<br>
데이터베이스가 일정한 성능을 유지할 수 있도록 비효율적인 요소들을 제거하고
성능 개선을 위한 SQL문장 추가와 같은 데이터베이스의 여러 요소들을 조정하는
작업을 의미합니다.
<br><br>

* 데이터베이스 유지보수
<br>
비즈니스 환경이 변함에 따라 업무 절차 및 데이터가 지속적으로 변하기 마련입니다.
따라서 새로운 테이블이 추가되거나 테이블에 새로운 컬럼이 추가되어야 할 수도 있겠죠.
이러한 일련의 작업을 유지보수라고 합니다. 이런 유지보수 작업이 원활히 진행될 수
있도록 초기에 설계자체가 유연하게 되어 있어야 합니다.
<br><br>

---

## 데이터 모델링의 주요 개념

앞서 언급한 것처럼 논리적 데이터베이스 설계란 현실세계에의 업무를 분석하여 이를
약속된 표기법을 사용하여 개념적 모델(`ERD`)로 표현하는 과정을 말하며 전체
데이터베이스 설계에서 핵심적인 부분입니다.
<br><br>

논리적 데이터베이스 설계 과정은 흔히 데이터 모델링이라는 용어를 사용하는데 이
데이터 모델링을 할 수 있기 위해서는 여러 가지 개념을 이해해야 합니다.
<br><br>

마치 지도를 만들려면 지도에 나오는 도로, 항만, 건물, 학교등을 표현할 수 있는
방법을 알고 있어야 하듯 데이터 모델링에서도 약속된 개념들을 사용하여
현실세계를 표현합니다. 이렇게 데이터 모델링을 수행하면 최종적인 산출물이
나오게 되는데 이것이 `ERD`입니다.
<br><br>

`ERD`를 그릴 줄도 알아야 하지만 다른 사람이 그린 `ERD`를 보고 역으로 현실세계의
업무를 추론할 수 도 있어야 합니다.
<br><br>

일단 간단한 형태의 `ERD` 예시를 보고 사용되는 용어에 대한 정리를 해 보죠.

{% include image.html
file='database-mysql-erd-terminology.png'
%}

우리가 이미 알고 있는 데이터베이스 용어와 모델링 용어를 비교하면 다음과 같습니다.

{% include image.html
file='database-mysql-database-modeling-terminology.png'
%}

---

## Entity(엔티티)

`Entity`는 현실세계를 데이터 관점에서 모델링할 때 사용되는 핵심적인 개념입니다.
<br><br>

Entity란 업무의 관심 대상이 되는 정보를 갖고 있거나 그에 대한 정보를 관리할
필요가 있는 유형, 무형의 개체를 말합니다.
<br><br>

예를 들어보죠. 인터넷 쇼핑 사이트에서 상품을 판매하는 업무를 가정합니다. 판매자의
입장에서 보면 상품을 판매하기 위해 누가 구입하는지를 확인할 수 있어야 합니다. 따라서
구매자(회원)에 대한 정보를 가지고 있어야 할 필요가 있습니다.
<br><br>

또한 구매자가 상품을 구매하기 위해서는 상품에 대한 사양과 가격 정보를 가지고 있어야 합니다.
<br><br>

우리가 일반적으로 그리하듯이 여러 상품을 구매할 때 장바구니를 이용하는데 장바구니에 대한
정보도 유지해야 합니다.
<br><br>

이와 같은 상황에서 정보를 관리해야 할 필요가 있는 회원, 상품, 장바구니 같은 개체를
`Entity`라고 합니다. 예에서 알 수 있듯이 Entity는 유형, 무형의 사물을 포함합니다.
<br><br>

당연히 Entity는 Entity의 instance와 구별 됩니다. 회원은 Entity이고 홍길동, 신사임당은
Entity의 instance가 됩니다. 객체지향의 class와 instance관계와 유사하다고 생각하시면
됩니다.
<br><br>

`Entity`는 `ERD`에서 아래 그림처럼 `Box`로 표현합니다.

{% include image.html
file='database-mysql-erd-entity.png'
%}

`Entity`를 굳이 분류기준을 가지고 분류할 필요는 없지만 분류에 대해 알아두면
`Entity`를 찾아내고 특징을 이해하는데 도움이 됩니다.
<br><br>

* 유형 엔티티 : 물리적인 형태가 있고 쉽게 엔티티임을 알수 있습니다.(예, 고객, 상품)
* 무형 엔티티 : 물리적인 형태가 없고 개념적으로 존재하는 엔티티(예, 부서조직, 장바구니)
* 문서 엔티티 : 업무 절차상에서 사용되는 문서나 장부에 대한 엔티티(예, 거래명세서, 금전출납부)
* 이력 엔티티 : 업무상 반복적으로 이루어지는 행위나 사건을 일자별, 시간별로 저장하기 
  위한 엔티티(예, 입고이력, 출고이력)
* 코드 엔티티 : 무형 엔티티의 일종으로 각종 코드를 관리하기 위한 엔티티(예, 직급 분류코드)
<br><br>

현실세계의 업무를 모델링 할 때 어떤 사물이 `Entity`인지 아닌지를 결정해야하는 시점이
있는데 이때는 다음과 같은 성질을 만족하는지 check해 보는게 도움이 됩니다.
<br><br>

* 업무필요성 : 업무의 관심 대상이 되는 사물이어야 합니다.
* 두개 이상의 instance 소유 : 엔티티가 의미가 있기 위해서는 두 개 이상의 instance를 갖는 것이 확인되어야 합니다. 
예를 들어, 수학 전문학원에서 과목 엔티티는 필요가 없겠죠.
* 속성의 소유 : 엔티티는 속성을 가지고 있어야 합니다. 엔티티의 마땅한 속성을 찾을 수 
없다면 업무 분석이 잘못 되었거나 속성으로 분류해야할 것을 엔티티로 분류한 것입니다.

---

## Attribute(속성)

{% include callout.html
type="danger"
content="속성이란 엔티티에서 관리해야 할 최소 단위의 정보 항목을 말합니다. 엔티티는
하나 이상의 속성을 포함해야 합니다."
%}

예를 들면, 회원 엔티티는 회원 ID, 이름, 전화번호 등을 관리하기 위한 것으로 이 ID,
이름, 전화번호가 바로 회원 엔티티의 속성이라고 할 수 있습니다. 당연히 현실세계의
하나의 엔티티는 많은 정보를 포함할 수 있지만 모델링 과정에서는 업무에 관심이 있는
정보 항목만을 속성으로 취급합니다.
<br><br>

아래의 그림은 속성에 대한 `ERD` 표현입니다.

{% include image.html
file='database-mysql-erd-attribute.png'
%}

엔티티는 table이 될 것이고 속성은 table의 column이 되겠죠?
<br><br>

---

## Relationship(관계)

`Relationship`(관계)란 두 엔티티 사이의 관련성을 나타내는 용어입니다.
현실세계에서는 여러 사물들이 상호 관련성을 가지고 움직이기 때문에 이를 모델링하면
엔티티와 엔티티 사이의 관계로 표현됩니다.
<br><br>

예를 들어, 학생들의 수강과목 정보를 파악하여 데이터베이스에 저장한다고 가정해보죠.
<br><br>

이 경우 학생과 수강과목은 독립적인 `entity`가 되며 개별 학생의 정보는 학생 엔티티에서
학생이 수강한 과목 정보는 수강과목 엔티티에서 관리될 것이기 때문에 학생 엔티티와
수강과목 엔티티는 어떤 관련성이 있습니다.
<br><br>

`ERD`에서는 두 엔티티가 관계있다는 사실을 표현하기 위해 두 엔티티를 선으로 연결합니다.

{% include image.html
file='database-mysql-erd-relationship-1.png'
%}

이 두 엔티티가 관계가 있다는 것을 조금 구체적으로 살펴보죠. 두 엔티티가 관계가 있다는
의미는 **상호 공유하는 속성**이 있다는 의미입니다.
<br><br>

만약 아래의 그림과 같은 형태의 테이블로 데이터베이스에 저장된다면 현실세계에서는
두 엔티티가 분명 관계가 있지만 두 테이블 사이에서는 아무런 관련성을 찾을 수가 없습니다.

{% include image.html
file='database-mysql-erd-relationship-2.png'
%}

누가 어떤 과목을 수강하는지를 알기 위해서는 다음 그림과 같이 데이터가 저장되어야
하겠죠.

{% include image.html
file='database-mysql-erd-relationship-3.png'
%}

위와 같이 데이터가 저장되어 있다면 우리는 어떤 학생이 어떤 과목을 수강하는지
쉽게 알 수 있습니다. 이렇게 두 테이블이 공유 속성을 가지고 있을 때 두 테이블은
**관계가 있다**라고 합니다.
<br><br>

이것을 엔티티로 표현하면 다음 그림처럼 표현할 수 있습니다.

{% include image.html
file='database-mysql-erd-relationship-4.png'
%}

여기서 주의해야 할 점은 상호 관계가 있는 두 엔티티에서 공유하는 속성의 이름이
반드시 같아야 할 필요는 없다는 것입니다. 속성의 이름이 달라도 실제 저장되는 값이
동일한 성격이고 동일한 데이터 타입을 가지면 공유하는 속성으로 볼 수 있습니다.
<br><br>

조금 더 세부적으로 살펴보죠.
<br><br>

`cardinality`(카디넬러티)는 두 엔티티 간의 관계를 보다 구체적으로 표현하는
방법의 하나로 각 엔티티에 속해 있는 instance들 간에 수적으로 어떤 관계에 있는지는
나타내는 개념입니다.
<br><br>

아래 그림은 학생 입장에서 보았을 때 수강 과목이 어떤 관계에 있는지를 보여줍니다.
그림에서 학생 1명은 수강과목 정보 2개와 관련성을 가지고 있습니다. 학생 1명이
N개의 수강과목과 관련이 있을 때 `ERD`에서는 다음과 같이 나타냅니다.

{% include image.html
file='database-mysql-erd-relationship-5.png'
alt='ERD Relationship-5'
%}

이번에는 수강과목의 입장에서 학생과의 관계를 나타내보죠. 아래 그림에서 수강과목
튜플을 하나 선택하여 그것과 관련이 있는 학생 튜플을 찾아보면 반드시 하나의 학생과
관련이 있음을 알 수 있습니다. 이와 같이 수강과목 1개의 정보가 학생 1명과 관계를
가질 때 `ERD`에서는 다음과 같이 표현합니다.

{% include image.html
file='database-mysql-erd-relationship-6.png'
%}

이 두 관계를 한꺼번에 표현하면 다음 그림처럼 표현할 수 있습니다.

{% include image.html
file='database-mysql-erd-relationship-7.png'
%}

일반적으로 두 엔티티 간의 `cardinality`는 `1:1(one-to-one)`, `1:N(one-to-many)`,
`M:N(many-to-many)`중 하나가 됩니다. 각각에 대해서 간단한 예를 들어보죠.
<br><br>

`cardinality`가 1:1인 경우입니다. 사실 이 경우 두 엔티티를 하나로 합쳐도 되는데
여러 이유로 일부러 나누어 놓은 경우가 있습니다. (관리의 편리성 때문에)

{% include image.html
file='database-mysql-erd-relationship-8.png'
%}

아래 그림은 `cardinality`가 1:N인 경우입니다. 가장 일반적인 경우죠.

{% include image.html
file='database-mysql-erd-relationship-9.png'
%}

아래 그림은 `cardinality`가 M:N인 경우입니다. 보시면 아시겠지만 이 관계에서는
두 엔티티가 관련이 있다는 정보를 두 엔티티만으로 설명하기에 부족합니다.
이 두 엔티티 사이에 또 다른 엔티티를 넣어서 1:N 관계로 전환시켜주는 작업을 진행합니다.

{% include image.html
file='database-mysql-erd-relationship-10.png'
%}

이번에는 `partiality`(참여도) 관점에서 두 엔티티의 관계를 살펴보죠.
<br><br>

두 엔티티 사이의 관계는 `cardinality` 관점에서도 표현할 수 있지만 참여도라는 관점에서도
표현할 수 있습니다.
<br><br>

`partiality`(참여도)에는 `mandatory`(필수), `optional`(선택) 두가지가 있습니다.
이 참여도 역시 어느 엔티티를 기준으로 바라보는가에 따라 달라집니다.
<br><br>

먼저 `optional partiality`(선택 참여도)에 대해서 알아보죠. 아래 그림처럼
학생과 학생의 취미 엔티티를 생각해보면 어떤 학생은 취미가 있지만 어떤 학생은 취미가
없을 수도 있습니다. 이처럼 기준이 되는 엔티티의 instance와 대응되는 instance가
상대방 엔티티에 있을 수도 있고 없을 수도 있을 때 선택관계에 있다고 합니다.
<br><br>

`ERD`에서 선택 참여도는 `cardinality`앞에 동그라미로 표현합니다.

{% include image.html
file='database-mysql-erd-relationship-11.png'
%}

필수 참여도는 선태과는 달리 기준이 되는 엔티티의 모든 instance에 대하여 대응되는
instance가 상대방 엔티티에 반드시 존재해야 하는 경우입니다.
<br><br>

`ERD`에서 필수 참여도는 `cardinality`앞에 `|`로 표현합니다.

{% include image.html
file='database-mysql-erd-relationship-12.png'
%}

상호 관계가 있는 두 엔티티는 부모-자식의 관계에 있는 경우가 많습니다. 두 엔티티의
부모, 자식 여부는 어느 쪽에 정보가 먼저 생성이 되는가에 따라 결정됩니다.
<br><br>

앞에서 살펴본 학생과 학생의 취미 엔티티를 예로 들자면, 학생의취미 정보는 학생 정보가
있어야만 존재할 수 있습니다. 이와 같은 관계에 있을 때 학생 엔티티를 `parent entity`
(부모 엔티티), 학생의취미 엔티티를 `child entity`(자식 엔티티)라고 합니다.
<br><br>

이 관계는 `ERD`상에 명시적으로 표현하지는 않지만 `cardinality`와 `partiality`를
살펴보면 알 수 있습니다. 일반적으로 두 엔티티가 부모-자식의 관계가 있다면 일반적으로
부모 엔티티와 자식 엔티티의 `cardinality`는 `1:N`이고 참여도는 부모쪽이 필수,
자식쪽이 선택으로 나타납니다.

{% include image.html
file='database-mysql-erd-relationship-13.png'
%}

---

## 주식별자와 외래식별자

`primary identifier`(주식별자)와 `foreign identifier`(외래식별자)의 개념은
우리 관계형 모델에서 `Primary Key`와 `Foreign Key`의 개념에 대응한다고 생각하시면
됩니다. 표기하는 방법만 살펴보면 될 듯 합니다. 두가지 방법 중 하나를 사용하는데
아래의 그림과 같습니다.

{% include image.html
file='database-mysql-erd-identifier-1.png'
%}

`foreign identifier`(외래식별자)까지 포함해서 그림으로 표현하면 다음 그림과
같습니다.

{% include image.html
file='database-mysql-erd-identifier-2.png'
%}

여기까지 데이터 모델링에 사용되는 기본적인 개념들에 대해서 알아보았습니다.
데이터 모델링은 현실세계를 데이터의 관점에서 분석하여 개념적인 모델로 표현하는
과정입니다.
<br><br>
데이터 모델링의 결과는 `ERD`로 표현되며 `ERD`에 포함된 엔티티, 속성, 관계가
`ERD`의 핵심 요소입니다. 관계는 `cardinality`와 `partiality` 두 가지 관점에서
표시가 되며 속성들 중에서 `primary identifier`와 `foreign identifier`가 별도로
구분됩니다.
<br><br>
정리하는 의미에서 모델링과 데이터베이스 구축에 대한 예를 보면서 간단하게
툴을 이용해서 `modeling`과 데이터베이스 구축을 자동으로 해 보도록 하겠습니다.

{% include image.html
file='database-mysql-modeling-database-build.png'
%}

위의 내용을 `MySQL workbench`를 이용해 `ERD`를 그리면 다음과 같습니다. 다른 tool보다는
우리가 한번이라도 썻던 Tool을 이용해보죠. 사실 `ERD`를 그리는 가장 전문적인 tool은
`ERWin`이라는 상용 프로그램입니다.

{% include image.html
file='database-mysql-modeling-erd-workbench-sample-1.png'
%}

이렇게 작성된 `ERD`를 이용해 데이터베이스를 구축할 수 있는 `script`를 자동으로 생성해보죠.
수행되는 절차는 다음과 같습니다.
<br><br>
* Database > Forward Engineering... 메뉴를 선택
* DBMS 연결 설정
* 생성되는 Database Option 설정(skip)
* 데이터베이스 연결 확인 및 Export할 object 선택
* 수행될 Query 생성
* Forward Engineering 실행 및 결과 확인


End.

{% include links.html %}
